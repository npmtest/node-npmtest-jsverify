{"/home/travis/build/npmtest/node-npmtest-jsverify/test.js":"/* istanbul instrument in package npmtest_jsverify */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jsverify/lib.npmtest_jsverify.js":"/* istanbul instrument in package npmtest_jsverify */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jsverify = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jsverify = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jsverify/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jsverify && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jsverify */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jsverify\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jsverify.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jsverify.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jsverify.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jsverify.__dirname + '/lib.npmtest_jsverify.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/jsverify.js":"/* @flow weak */\n/**\n  # JSVerify\n\n  <img src=\"https://raw.githubusercontent.com/jsverify/jsverify/master/jsverify-300.png\" align=\"right\" height=\"100\" />\n\n  > Property-based checking. Like QuickCheck.\n\n  [![Build Status](https://secure.travis-ci.org/jsverify/jsverify.svg?branch=master)](http://travis-ci.org/jsverify/jsverify)\n  [![NPM version](https://badge.fury.io/js/jsverify.svg)](http://badge.fury.io/js/jsverify)\n  [![Dependency Status](https://david-dm.org/jsverify/jsverify.svg)](https://david-dm.org/jsverify/jsverify)\n  [![devDependency Status](https://david-dm.org/jsverify/jsverify/dev-status.svg)](https://david-dm.org/jsverify/jsverify#info=devDependencies)\n  [![Code Climate](https://img.shields.io/codeclimate/github/jsverify/jsverify.svg)](https://codeclimate.com/github/jsverify/jsverify)\n\n  ## Getting Started\n\n  Install the module with: `npm install jsverify`\n\n  ## Synopsis\n\n  ```js\n  var jsc = require(\"jsverify\");\n\n  // forall (f : bool -> bool) (b : bool), f (f (f b)) = f(b).\n  var boolFnAppliedThrice =\n    jsc.forall(\"bool -> bool\", \"bool\", function (f, b) {\n      return f(f(f(b))) === f(b);\n    });\n\n  jsc.assert(boolFnAppliedThrice);\n  // OK, passed 100 tests\n  ```\n*/\n\"use strict\";\n\n/**\n  ## Documentation\n\n  ### Usage with [mocha](http://mochajs.org/)\n\n  Using jsverify with mocha is easy, just define the properties and use `jsverify.assert`.\n\n  Starting from version 0.4.3 you can write your specs without any boilerplate:\n\n  ```js\n  describe(\"sort\", function () {\n    jsc.property(\"idempotent\", \"array nat\", function (arr) {\n      return _.isEqual(sort(sort(arr)), sort(arr));\n    });\n  });\n  ```\n\n  Starting from version 0.8.0 you can write the specs in TypeScript. There are\n  typings provided. The drawback is that you cannot use type DSL:\n\n  ```typescript\n  describe(\"basic jsverify usage\", () => {\n    jsc.property(\"(b && b) === b\", jsc.bool, b => (b && b) === b);\n\n    jsc.property(\"boolean fn thrice\", jsc.fn(jsc.bool), jsc.bool, (f, b) =>\n      f(f(f(b))) === f(b)\n    );\n  });\n  ```\n\n  You can also provide `--jsverifyRngState state` command line argument, to run tests with particular random generator state.\n\n  ```\n  $ mocha examples/nat.js\n\n  1) natural numbers are less than 90:\n   Error: Failed after 49 tests and 1 shrinks. rngState: 074e9b5f037a8c21d6; Counterexample: 90;\n\n  $ mocha examples/nat.js --grep 'are less than' --jsverifyRngState 074e9b5f037a8c21d6\n\n  1) natural numbers are less than 90:\n     Error: Failed after 1 tests and 1 shrinks. rngState: 074e9b5f037a8c21d6; Counterexample: 90;\n  ```\n\n  Erroneous case is found with first try.\n\n  ### Usage with [jasmine](https://jasmine.github.io/)\n\n  Check [jasmineHelpers.js](helpers/jasmineHelpers.js) and [jasmineHelpers2.js](helpers/jasmineHelpers2.js) for jasmine 1.3 and 2.0 respectively.\n\n  ## API Reference\n\n  > _Testing shows the presence, not the absence of bugs._\n  >\n  > Edsger W. Dijkstra\n\n  To show that propositions hold, we need to construct proofs.\n  There are two extremes: proof by example (unit tests) and formal (machine-checked) proof.\n  Property-based testing is somewhere in between.\n  We formulate propositions, invariants or other properties we believe to hold, but\n  only test it to hold for numerous (randomly generated) values.\n\n  Types and function signatures are written in [Coq](http://coq.inria.fr/)/[Haskell](http://www.haskell.org/haskellwiki/Haskell)-influenced style:\n  C# -style `List<T> filter(List<T> v, Func<T, bool> predicate)` is represented by\n  `filter(v: array T, predicate: T -> bool): array T` in our style.\n\n  Methods and objects live in `jsc` object, e.g. `shrink.bless` method is used by\n  ```js\n  var jsc = require(\"jsverify\");\n  var foo = jsc.shrink.bless(...);\n  ```\n\n  Methods starting with `.dot` are prototype methods:\n  ```js\n  var arb = jsc.nat;\n  var arb2 = jsc.nat.smap(f, g);\n  ```\n\n  `jsverify` can operate with both synchronous and asynchronous-promise properties.\n  Generally every property can be wrapped inside [functor](http://learnyouahaskell.com/functors-applicative-functors-and-monoids),\n  for now in either identity or promise functor, for synchronous and promise properties respectively.\n*/\n\nvar assert = require(\"assert\");\nvar lazyseq = require(\"lazy-seq\");\n\nvar api = require(\"./api.js\");\nvar either = require(\"./either.js\");\nvar environment = require(\"./environment.js\");\nvar FMap = require(\"./finitemap.js\");\nvar fn = require(\"./fn.js\");\nvar functor = require(\"./functor.js\");\nvar random = require(\"./random.js\");\nvar show = require(\"./show.js\");\nvar shrink = require(\"./shrink.js\");\nvar suchthat = require(\"./suchthat.js\");\nvar sum = require(\"./sum.js\");\nvar typify = require(\"./typify.js\");\nvar utils = require(\"./utils.js\");\n\n/**\n  ### Properties\n*/\n\nfunction shrinkResult(arbs, x, test, size, shrinksN, exc, transform) {\n  assert(arbs.length === x.length, \"shrinkResult: arbs and x has to be of same size\");\n  assert(typeof size === \"number\", \"shrinkResult: size should be number\");\n  assert(typeof shrinksN === \"number\", \"shrinkResult: shrinkN should be number\");\n\n  var shrinks = utils.pluck(arbs, \"shrink\");\n  var shows = utils.pluck(arbs, \"show\");\n\n  var shrinked = shrink.tuple(shrinks, x);\n\n  var shrinkP = lazyseq.fold(shrinked, true, function (y, rest) {\n    var t = test(size, y, shrinksN + 1);\n    return functor.map(t, function (tprime) {\n      return tprime !== true ? tprime : rest();\n    });\n  });\n\n  return functor.map(shrinkP, function (shrinkPPrime) {\n    if (shrinkPPrime === true) {\n      var res = {\n        counterexample: x,\n        counterexamplestr: show.tuple(shows, x),\n        shrinks: shrinksN,\n        exc: exc,\n      };\n      return transform(res);\n    } else {\n      return shrinkPPrime;\n    }\n  });\n}\n\nfunction isArbitrary(arb) {\n  return (typeof arb === \"object\" || typeof arb === \"function\") &&\n    typeof arb.generator === \"function\" &&\n    typeof arb.shrink === \"function\" &&\n    typeof arb.show === \"function\";\n}\n\n/**\n  - `forall(arbs: arbitrary a ..., userenv: (map arbitrary)?, prop : a -> property): property`\n\n      Property constructor\n*/\nfunction forall() {\n  var args = Array.prototype.slice.call(arguments);\n  var gens = args.slice(0, -1);\n  var property = args[args.length - 1];\n  var env;\n\n  var lastgen = gens[gens.length - 1];\n\n  if (!isArbitrary(lastgen) && typeof lastgen !== \"string\") {\n    env = utils.merge(environment, lastgen);\n    gens = gens.slice(0, -1);\n  } else {\n    env = environment;\n  }\n\n  assert(gens.length > 0, \"forall requires at least single generator\");\n\n  // Map typify-dsl to hard generators\n  gens = gens.map(function (g) {\n    g = typeof g === \"string\" ? typify.parseTypify(env, g) : g;\n    return utils.force(g);\n  });\n\n  assert(typeof property === \"function\", \"property should be a function\");\n\n  function test(size, x, shrinks) {\n    assert(Array.isArray(x), \"generators results should be always tuple\");\n\n    return functor.bind(property, x, function (r, exc) {\n      if (r === true) {\n        return true;\n      } else if (typeof r === \"function\") {\n        var rRec = r(size);\n\n        return functor.map(rRec, function (rRecPrime) {\n          if (rRecPrime === true) {\n            return true;\n          } else {\n            return shrinkResult(gens, x, test, size, shrinks, exc, function (rr) {\n              return {\n                counterexample: rr.counterexample.concat(rRecPrime.counterexample),\n                counterexamplestr: rr.counterexamplestr, // + \"; \" + rRec.counterexamplestr,\n                shrinks: rr.shrinks,\n                exc: rr.exc || rRecPrime.exc,\n              };\n            });\n          }\n        });\n      } else {\n        return shrinkResult(gens, x, test, size, shrinks, exc || r, utils.identity);\n      }\n    });\n  }\n\n  return function (size) {\n    var x = gens.map(function (arb) { return arb.generator(size); });\n    var r = test(size, x, 0);\n    return r;\n  };\n}\n\nfunction formatFailedCase(r, state, includeStack) {\n  var msg = \"Failed after \" + r.tests + \" tests and \" + r.shrinks + \" shrinks. \";\n  msg += \"rngState: \" + (r.rngState || state) + \"; \";\n  msg += \"Counterexample: \" + r.counterexamplestr + \"; \";\n  if (r.exc) {\n    if (r.exc instanceof Error) {\n      msg += \"Exception: \" + r.exc.message;\n      if (includeStack) {\n        msg += \"\\nStack trace: \" + r.exc.stack;\n      }\n    } else {\n      msg += \"Error: \" + r.exc;\n    }\n  }\n  return msg;\n}\n\nfunction findRngState(argv) { // eslint-disable-line consistent-return\n  for (var i = 0; i < argv.length - 1; i++) {\n    if (argv[i] === \"--jsverifyRngState\") {\n      return argv[i + 1];\n    }\n  }\n}\n\n/**\n  - `check (prop: property, opts: checkoptions?): result`\n\n      Run random checks for given `prop`. If `prop` is promise based, result is also wrapped in promise.\n\n      Options:\n      - `opts.tests` - test count to run, default 100\n      - `opts.size`  - maximum size of generated values, default 50\n      - `opts.quiet` - do not `console.log`\n      - `opts.rngState` - state string for the rng\n\n      The `result` is `true` if check succeeds, otherwise it's an object with various fields:\n      - `counterexample` - an input for which property fails.\n      - `tests` - number of tests run before failing case is found\n      - `shrinks` - number of shrinks performed\n      - `exc` - an optional exception thrown by property function\n      - `rngState` - random number generator's state before execution of the property\n*/\nfunction check(property, opts) {\n  opts = opts || {};\n  opts.size = opts.size || 50;\n  opts.tests = opts.tests || 100;\n  opts.quiet = opts.quiet || false;\n\n  assert(typeof property === \"function\", \"property should be a function\");\n\n  var state;\n\n  if (opts.rngState) {\n    random.setStateString(opts.rngState);\n  } else if (typeof process !== \"undefined\") {\n    var argvState = findRngState(process.argv);\n    if (argvState) {\n      random.setStateString(argvState);\n    }\n  }\n\n  function loop(i) {\n    state = random.currentStateString();\n    if (i > opts.tests) {\n      return true;\n    }\n\n    var size = random(0, opts.size);\n\n    // wrap non-promises in trampoline\n    var r = functor.pure(property(size));\n\n    return functor.map(r, function (rPrime) {\n      if (rPrime === true) {\n        return loop(i + 1);\n      } else {\n        rPrime.tests = i;\n        /* global console */\n        if (!opts.quiet) {\n          console.error(formatFailedCase(rPrime, state, true), rPrime.counterexample);\n        }\n        return rPrime;\n      }\n    });\n  }\n\n  return functor.run(functor.map(loop(1), function (r) {\n    if (r === true) {\n      if (!opts.quiet) { console.info(\"OK, passed \" + opts.tests + \" tests\"); }\n    } else {\n      r.rngState = state;\n    }\n\n    return r;\n  }));\n}\n\n/**\n  - `assert(prop: property, opts: checkoptions?) : void`\n\n      Same as `check`, but throw exception if property doesn't hold.\n*/\nfunction checkThrow(property, opts) {\n  opts = opts || {};\n  if (opts.quiet === undefined) {\n    opts.quiet = true;\n  }\n\n  return functor.run(functor.map(check(property, opts), function (r) {\n    if (r !== true) {\n      if (r.exc instanceof Error) {\n        r.exc.message = formatFailedCase(r);\n        throw r.exc;\n      } else {\n        throw new Error(formatFailedCase(r));\n      }\n    }\n  }));\n}\n\n/**\n   - `property(name: string, ...)`\n\n      Assuming there is globally defined `it`, the same as:\n\n      ```js\n      it(name, function () {\n        jsc.assert(jsc.forall(...));\n      }\n      ```\n\n      You can use `property` to write facts too:\n      ```js\n      jsc.property(\"+0 === -0\", function () {\n        return +0 === -0;\n      });\n      ```\n*/\nfunction bddProperty(name) {\n  /* global it: true */\n  var args = Array.prototype.slice.call(arguments, 1);\n  if (args.length === 1) {\n    it(name, function () {\n      return functor.run(functor.map(args[0](), function (result) { // eslint-disable-line consistent-return\n        if (typeof result === \"function\") {\n          return checkThrow(result);\n        } else if (result !== true) {\n          throw new Error(name + \" doesn't hold\");\n        }\n      }));\n    });\n  } else {\n    var prop = forall.apply(undefined, args);\n    it(name, function () {\n      return checkThrow(prop);\n    });\n  }\n  /* global it: false */\n}\n\n/**\n  - `compile(desc: string, env: typeEnv?): arbitrary a`\n\n      Compile the type description in provided type environment, or default one.\n*/\nfunction compile(str, env) {\n  env = env ? utils.merge(environment, env) : environment;\n  return typify.parseTypify(env, str);\n}\n\n/**\n  - `sampler(arb: arbitrary a, genSize: nat = 10): (sampleSize: nat?) -> a`\n\n      Create a sampler for a given arbitrary with an optional size. Handy when used in\n      a REPL:\n      ```\n      > jsc = require('jsverify') // or require('./lib/jsverify') w/in the project\n      ...\n      > jsonSampler = jsc.sampler(jsc.json, 4)\n      [Function]\n      > jsonSampler()\n      0.08467432763427496\n      > jsonSampler()\n      [ [ [] ] ]\n      > jsonSampler()\n      ''\n      > sampledJson(2)\n      [-0.4199344692751765, false]\n      ```\n*/\nfunction sampler(arb, size) {\n  size = typeof size === \"number\" ? Math.abs(size) : 10;\n  return function (count) {\n    if (typeof count === \"number\") {\n      var acc = [];\n      count = Math.abs(count);\n      for (var i = 0; i < count; i++) {\n        acc.push(arb.generator(size));\n      }\n      return acc;\n    } else {\n      return arb.generator(size);\n    }\n  };\n}\n\n/**\n  - `throws(block: () -> a, error: class?, message: string?): bool`\n\n    Executes nullary function `block`. Returns `true` if `block` throws. See [assert.throws](https://nodejs.org/api/assert.html#assert_assert_throws_block_error_message)\n*/\nfunction throws(block, error, message) {\n  assert(error === undefined || typeof error === \"function\", \"throws: error parameter must be a constructor\");\n  assert(message === undefined || typeof message === \"string\", \"throws: message parameter must be a string\");\n\n  try {\n    block();\n    return false;\n  } catch (e) {\n    if (error !== undefined) {\n      if (e instanceof error) {\n        return message === undefined || e.message === message;\n      } else {\n        return false;\n      }\n    } else {\n      return true;\n    }\n  }\n}\n\n/**\n  - `assertForall(arbs: arbitrary a ..., userenv: (map arbitrary)?, prop : a -> property): void`\n\n     Combines 'assert' and 'forall'.\n     Constructs a property with forall from arguments, then throws an exception if the property doesn't hold.\n     Options for 'assert' cannot be set here - use assert(forall(...)) if you need that.\n*/\nfunction assertForall() {\n  return checkThrow(forall.apply(null, arguments));\n}\n\n/**\n  - `checkForall(arbs: arbitrary a ..., userenv: (map arbitrary)?, prop : a -> property): result`\n\n    Combines 'check' and 'forall'.\n    Constructs a property with forall from arguments, and returns a value based on if the property holds or not.\n    See 'check' for description of return value.\n\n    Options for 'check' cannot be set here - use check(forall(...)) if you need that.\n*/\nfunction checkForall() {\n  return check(forall.apply(null, arguments));\n}\n\n/**\n  ### Types\n\n  - `generator a` is a function `(size: nat) -> a`.\n  - `show` is a function `a -> string`.\n  - `shrink` is a function `a -> [a]`, returning *smaller* values.\n  - `arbitrary a` is a triple of generator, shrink and show functions.\n      - `{ generator: nat -> a, shrink : a -> array a, show: a -> string }`\n\n  ### Blessing\n\n  We chose to represent generators and shrinks by functions, yet we would\n  like to have additional methods on them. Thus we *bless* objects with\n  additional properties.\n\n  Usually you don't need to bless anything explicitly, as all combinators\n  return blessed values.\n\n  See [perldoc for bless](http://perldoc.perl.org/functions/bless.html).\n*/\n\n/// include ./typify.js\n/// include ./arbitraryBless.js\n/// include ./bless.js\n/// include ./primitive.js\n/// include ./arbitrary.js\n/// include ./recordWithEnv.js\n/// include ./record.js\n/// include ./string.js\n/// include ./fn.js\n/// include ./small.js\n/// include ./generator.js\n/// include ./shrink.js\n/// include ./show.js\n/// include ./random.js\n/// include ./either.js\n/// include ./utils.js\n\n// Export\nvar jsc = {\n  forall: forall,\n  check: check,\n  assert: checkThrow,\n  assertForall: assertForall,\n  checkForall: checkForall,\n  property: bddProperty,\n  sampler: sampler,\n  throws: throws,\n\n  // generators\n  fn: fn.fn,\n  fun: fn.fn,\n  suchthat: suchthat.suchthat,\n\n  // either\n  left: either.left,\n  right: either.right,\n\n  // sum\n  addend: sum.addend,\n\n  // compile\n  compile: compile,\n\n  generator: api.generator,\n  shrink: api.shrink,\n\n  // internal utility lib\n  random: random,\n\n  show: show,\n  utils: utils,\n  _: {\n    FMap: FMap,\n  },\n};\n\n/* primitives */\n/* eslint-disable guard-for-in */\nfor (var k in api.arbitrary) {\n  jsc[k] = api.arbitrary[k];\n}\n/* eslint-enable guard-for-in */\n\nmodule.exports = jsc;\n\n/// plain ../FAQ.md\n/// plain ../CONTRIBUTING.md\n/// plain ../CHANGELOG.md\n/// plain ../related-work.md\n/// plain ../LICENSE\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/api.js":"\"use strict\";\n\nvar arbitrary = require(\"./arbitrary.js\");\nvar bless = require(\"./bless.js\");\nvar dict = require(\"./dict.js\");\nvar generator = require(\"./generator.js\");\nvar json = require(\"./json.js\");\nvar primitive = require(\"./primitive.js\");\nvar record = require(\"./record.js\");\nvar recordWithEnv = require(\"./recordWithEnv.js\");\nvar shrink = require(\"./shrink.js\");\nvar small = require(\"./small.js\");\nvar string = require(\"./string.js\");\n\nvar api = {\n  arbitrary: {\n    small: small.arbitrary,\n    bless: bless,\n    record: recordWithEnv,\n    nonshrink: arbitrary.nonshrink,\n    pair: arbitrary.pair,\n    either: arbitrary.either,\n    unit: arbitrary.unit,\n    dict: arbitrary.dict,\n    json: arbitrary.json,\n    nearray: arbitrary.nearray,\n    array: arbitrary.array,\n    tuple: arbitrary.tuple,\n    sum: arbitrary.sum,\n    oneof: arbitrary.oneof,\n    recursive: arbitrary.recursive,\n    letrec: arbitrary.letrec,\n  },\n  generator: {\n    dict: dict.generator,\n    json: json.json.generator,\n    small: small.generator,\n    record: record.generator,\n  },\n  shrink: {\n    record: record.shrink,\n  },\n};\n\n// Re-export stuff from internal modules\n/* eslint-disable guard-for-in */\nvar k;\nfor (k in primitive) {\n  api.arbitrary[k] = primitive[k];\n}\nfor (k in string) {\n  api.arbitrary[k] = string[k];\n}\nfor (k in shrink) {\n  api.shrink[k] = shrink[k];\n}\nfor (k in generator) {\n  api.generator[k] = generator[k];\n}\nmodule.exports = api;\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/arbitrary.js":"/* @flow weak */\n\"use strict\";\n\nvar arbitraryAssert = require(\"./arbitraryAssert.js\");\nvar arbitraryBless = require(\"./arbitraryBless.js\");\nvar array = require(\"./array.js\");\nvar assert = require(\"assert\");\nvar dict = require(\"./dict.js\");\nvar generator = require(\"./generator.js\");\nvar json = require(\"./json.js\");\nvar pair = require(\"./pair.js\");\nvar show = require(\"./show.js\");\nvar shrink = require(\"./shrink.js\");\nvar utils = require(\"./utils.js\");\n\n/**\n  ### Arbitrary combinators\n*/\n\n/**\n  - `nonshrink(arb: arbitrary a): arbitrary a`\n\n      Non shrinkable version of arbitrary `arb`.\n*/\nfunction nonshrink(arb) {\n  arb = utils.force(arb);\n\n  return arbitraryBless({\n    generator: arb.generator,\n    shrink: shrink.noop,\n    show: arb.show,\n  });\n}\n\n/**\n  - `unit: arbitrary ()`\n*/\nvar unit = arbitraryBless({\n  generator: generator.unit,\n  shrink: shrink.noop,\n  show: show.def,\n});\n\n/**\n  - `either(arbA: arbitrary a, arbB : arbitrary b): arbitrary (either a b)`\n*/\nfunction either(a, b) {\n  a = utils.force(a || json.json);\n  b = utils.force(b || json.json);\n\n  arbitraryAssert(a);\n  arbitraryAssert(b);\n\n  return arbitraryBless({\n    generator: generator.either(a.generator, b.generator),\n    shrink: shrink.either(a.shrink, b.shrink),\n    show: show.either(a.show, b.show),\n  });\n}\n\n/**\n  - `pair(arbA: arbitrary a, arbB : arbitrary b): arbitrary (pair a b)`\n\n      If not specified `a` and `b` are equal to `value()`.\n*/\nfunction pairArb(a, b) {\n  return pair.pair(a || json.json, b || json.json);\n}\n\n/**\n  - `tuple(arbs: (arbitrary a, arbitrary b...)): arbitrary (a, b...)`\n*/\nfunction tuple(arbs) {\n  arbs = arbs.map(utils.force);\n  return arbitraryBless({\n    generator: generator.tuple(utils.pluck(arbs, \"generator\")),\n    shrink: shrink.tuple(utils.pluck(arbs, \"shrink\")),\n    show: show.tuple(utils.pluck(arbs, \"show\")),\n  });\n}\n\n/**\n  - `sum(arbs: (arbitrary a, arbitrary b...)): arbitrary (a | b ...)`\n*/\nfunction sum(arbs) {\n  arbs = arbs.map(utils.force);\n  return arbitraryBless({\n    generator: generator.sum(utils.pluck(arbs, \"generator\")),\n    shrink: shrink.sum(utils.pluck(arbs, \"shrink\")),\n    show: show.sum(utils.pluck(arbs, \"show\")),\n  });\n}\n/**\n  - `dict(arb: arbitrary a): arbitrary (dict a)`\n\n      Generates a JavaScript object with properties of type `A`.\n*/\nfunction dictArb(arb) {\n  return dict.arbitrary(arb || json.json);\n}\n\n/**\n  - `array(arb: arbitrary a): arbitrary (array a)`\n*/\nfunction arrayArb(arb) {\n  return array.array(arb || json.json);\n}\n\n/**\n  - `nearray(arb: arbitrary a): arbitrary (array a)`\n*/\nfunction nearrayArb(arb) {\n  return array.nearray(arb || json.json);\n}\n\n/**\n  - `json: arbitrary json`\n\n       JavaScript Objects: boolean, number, string, null, array of `json` values or object with `json` values.\n*/\nvar jsonArb = json.json;\n\n/**\n  - `oneof(gs : array (arbitrary a)...) : arbitrary a`\n\n      Randomly uses one of the given arbitraries.\n*/\nfunction oneof() {\n  assert(arguments.length !== 0, \"oneof: at least one parameter expected\");\n\n  // TODO: write this in more functional way\n  var generators = [];\n  var append = function (a) {\n    generators.push(utils.force(a).generator);\n  };\n  for (var i = 0; i < arguments.length; i++) {\n    var arg = arguments[i];\n    if (utils.isArray(arg)) {\n      arg.forEach(append);\n    } else {\n      append(arg);\n    }\n  }\n\n  return arbitraryBless({\n    generator: generator.oneof(generators),\n    // TODO: make shrink\n    shrink: shrink.noop,\n    show: show.def,\n  });\n}\n\n// Return a lazy arbitrary that delegates to another arbitrary at its\n// 'strict' property. An arbitrary must be assigned to that property before\n// this arbitrary can generate anything.\nfunction lazyArbitrary() {\n  var arb = {};\n  // This function must be pure because it will not be called with\n  // meaningful context.\n  arb.generator = generator.bless(function (size) {\n    return arb.strict.generator(size);\n  });\n  arb.shrink = shrink.noop;\n  arb.show = show.def;\n  arb = arbitraryBless(arb);\n  return arb;\n}\n\n/**\n  - ```js\n    letrec(\n      (tie: key -> (arbitrary a | arbitrary b | ...))\n      -> { key: arbitrary a, key: arbitrary b, ... }):\n    { key: arbitrary a, key: arbitrary b, ... }\n    ```\n\n    Mutually recursive definitions. Every reference to a sibling arbitrary\n    should go through the `tie` function.\n\n    ```js\n    { arb1, arb2 } = jsc.letrec(function (tie) {\n      return {\n        arb1: jsc.tuple(jsc.int, jsc.oneof(jsc.const(null), tie(\"arb2\"))),\n        arb2: jsc.tuple(jsc.bool, jsc.oneof(jsc.const(null), tie(\"arb1\"))),\n      }\n    });\n    ```\n*/\nfunction letrec(definition) {\n  // We must use a lazy dictionary because we do not know the key set\n  // before calling the definition.\n  var lazyArbs = {};\n\n  function tie(name) {\n    if (!lazyArbs.hasOwnProperty(name)) {\n      lazyArbs[name] = lazyArbitrary();\n    }\n    return lazyArbs[name];\n  }\n\n  var strictArbs = definition(tie);\n\n  Object.keys(lazyArbs).forEach(function (key) {\n    var strictArb = strictArbs[key];\n    if (!strictArb) {\n      throw new Error(\"undefined lazy arbitrary: \" + key);\n    }\n    lazyArbs[key].strict = strictArb;\n  });\n\n  return strictArbs;\n}\n\nfunction recursive(arbZ, arbS) {\n  var genZ = arbZ.generator;\n  var genS = function (recGen) {\n    var recArb = arbitraryBless({\n      generator: recGen,\n      shrink: shrink.noop,\n      show: show.def,\n    });\n    return arbS(recArb).generator;\n  };\n\n  var gen = generator.recursive(genZ, genS);\n  return arbitraryBless({\n    generator: gen,\n    shrink: shrink.noop,\n    show: show.def,\n  });\n}\n\nmodule.exports = {\n  nonshrink: nonshrink,\n  pair: pairArb,\n  either: either,\n  unit: unit,\n  dict: dictArb,\n  json: jsonArb,\n  nearray: nearrayArb,\n  array: arrayArb,\n  tuple: tuple,\n  sum: sum,\n  oneof: oneof,\n  recursive: recursive,\n  letrec: letrec,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/arbitraryAssert.js":"\"use strict\";\n\nvar assert = require(\"assert\");\n\nfunction arbitraryAssert(arb) {\n  assert(arb !== undefined && arb !== null && typeof arb === \"object\", \"arb should be an object\");\n  assert(typeof arb.generator === \"function\" && typeof arb.generator.map === \"function\",\n    \"arb.generator should be a function\");\n  assert(typeof arb.shrink === \"function\" && typeof arb.shrink.smap === \"function\",\n    \"arb.shrink should be a function\");\n  assert(typeof arb.show === \"function\", \"arb.show should be a function\");\n  assert(typeof arb.smap === \"function\", \"arb.smap should be a function\");\n}\n\nmodule.exports = arbitraryAssert;\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/arbitraryBless.js":"\"use strict\";\n\nvar show = require(\"./show.js\");\n\n/**\n  ### Arbitrary data\n*/\n\n// Blessing: i.e adding prototype\n/* eslint-disable no-use-before-define */\nfunction arbitraryProtoSMap(f, g, newShow) {\n  /* jshint validthis:true */\n  var arb = this; // eslint-disable-line no-invalid-this\n  return arbitraryBless({\n    generator: arb.generator.map(f),\n    shrink: arb.shrink.smap(f, g),\n    show: newShow || show.def,\n  });\n}\n/* eslint-enable no-use-before-define */\n\n/**\n  - `.smap(f: a -> b, g: b -> a, newShow: (b -> string)?): arbitrary b`\n\n      Transform `arbitrary a` into `arbitrary b`. For example:\n\n      `g` should be a [right inverse](http://en.wikipedia.org/wiki/Surjective_function#Surjections_as_right_invertible_functions) of `f`, but doesn't need to be complete inverse.\n      i.e. i.e. `f` doesn't need to be invertible, only surjective.\n\n      ```js\n      var positiveIntegersArb = nat.smap(\n        function (x) { return x + 1; },\n        function (x) { return x - 1; });\n      ```\n\n      ```js\n      var setNatArb =  jsc.array(jsc.nat).smap(_.uniq, _.identity);\n      ```\n\n      Right inverse means that *f(g(y)) = y* for all *y* in *Y*. Here *Y* is a type of **arrays of unique natural numbers**. For them\n      ```js\n      _.uniq(_.identity(y)) = _.uniq(y) = y\n      ```\n\n      Opposite: *g(f(x))* for all *x* in *X*, doesn't need to hold. *X* is **arrays of natural numbers**:\n      ```js\n      _.identity(_uniq([0, 0])) = [0]] != [0, 0]\n      ```\n\n      We need an inverse for shrinking, and there right inverse is enough. We can always *pull back* `smap`ped value, shrink the preimage, and *map* or *push forward* shrunken preimages again.\n*/\nfunction arbitraryBless(arb) {\n  arb.smap = arbitraryProtoSMap;\n  return arb;\n}\n\nmodule.exports = arbitraryBless;\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/show.js":"\n/* @flow weak */\n\"use strict\";\n\n/**\n  ### Show functions\n*/\n\nvar utils = require(\"./utils.js\");\n\n/**\n  - `show.def(x : a): string`\n\n      Currently implemented as `JSON.stringify`.\n*/\nfunction showDef(obj) {\n  return JSON.stringify(obj);\n}\n\n/**\n  - `show.pair(showA: a -> string, showB: b -> string, x: (a, b)): string`\n*/\nfunction showPair(showA, showB) {\n  var result = function (p) {\n    return \"(\" + showA(p[0]) + \", \" + showB(p[1]) + \")\";\n  };\n\n  return utils.curried3(result, arguments);\n}\n\n/**\n  - `show.either(showA: a -> string, showB: b -> string, e: either a b): string`\n*/\nfunction showEither(showA, showB) {\n  function showLeft(value) {\n    return \"Left(\" + showA(value) + \")\";\n  }\n\n  function showRight(value) {\n    return \"Right(\" + showB(value) + \")\";\n  }\n\n  var result = function (e) {\n    return e.either(showLeft, showRight);\n  };\n\n  return utils.curried3(result, arguments);\n}\n\n/**\n  - `show.tuple(shrinks: (a -> string, b -> string...), x: (a, b...)): string`\n*/\nfunction showTuple(shows) {\n  var result = function (objs) {\n    var strs = [];\n    for (var i = 0; i < shows.length; i++) {\n      strs.push(shows[i](objs[i]));\n    }\n    return strs.join(\"; \");\n  };\n\n  return utils.curried2(result, arguments);\n}\n\n/**\n  - `show.sum(shrinks: (a -> string, b -> string...), x: (a | b ...)): string`\n*/\nfunction showSum(shows) {\n  var result = function (sum) {\n    return sum.fold(function (idx, n, value) {\n      return \"Sum(\" + idx + \"/\" + n + \": \" + shows[idx](value) + \")\";\n    });\n  };\n\n  return utils.curried2(result, arguments);\n}\n\n/**\n  - `show.array(shrink: a -> string, x: array a): string`\n*/\nfunction showArray(show) {\n  var result = function (arr) {\n    return \"[\" + arr.map(show).join(\", \") + \"]\";\n  };\n\n  return utils.curried2(result, arguments);\n}\n\nmodule.exports = {\n  def: showDef,\n  pair: showPair,\n  either: showEither,\n  tuple: showTuple,\n  sum: showSum,\n  array: showArray,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/utils.js":"/* @flow weak */\n\"use strict\";\n\nvar isArray = Array.isArray;\nfunction isObject(o) {\n  /* eslint-disable no-new-object */\n  return new Object(o) === o;\n  /* eslint-enable no-new-object */\n}\n\n/* undefined-safe isNaN */\nfunction isNaN(n) {\n  return typeof n === \"number\" && n !== n;\n}\n\n/**\n  ### Utility functions\n\n  Utility functions are exposed (and documented) only to make contributions to jsverify more easy.\n  The changes here don't follow semver, i.e. there might be backward-incompatible changes even in patch releases.\n\n  Use [underscore.js](http://underscorejs.org/), [lodash](https://lodash.com/), [ramda](http://ramda.github.io/ramdocs/docs/), [lazy.js](http://danieltao.com/lazy.js/) or some other utility belt.\n*/\n\n/* Simple sort */\nfunction sort(arr) {\n  var res = arr.slice();\n  res.sort();\n  return res;\n}\n\n/**\n  - `utils.isEqual(x: json, y: json): bool`\n\n      Equality test for `json` objects.\n*/\nfunction isEqual(a, b) {\n  var i;\n\n  if (isNaN(a) && isNaN(b)) {\n    return true;\n  }\n\n  if (a === b) {\n    return true;\n  } else if (isArray(a) && isArray(b) && a.length === b.length) {\n    for (i = 0; i < a.length; i++) {\n      if (!isEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  } else if (isObject(a) && isObject(b) && !isArray(a) && !isArray(b)) {\n    var akeys = Object.keys(a);\n    var bkeys = Object.keys(b);\n    if (!isEqual(sort(akeys), sort(bkeys))) {\n      return false;\n    }\n\n    for (i = 0; i < akeys.length; i++) {\n      if (!isEqual(a[akeys[i]], b[akeys[i]])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  return false;\n}\n\n/**\n  - `utils.isApproxEqual(x: a, y: b, opts: obj): bool`\n\n      Tests whether two objects are approximately and optimistically equal.\n      Returns `false` only if they are distinguishable not equal.\n      Returns `true` when `x` and `y` are `NaN`.\n      This function works with cyclic data.\n\n      Takes optional 'opts' parameter with properties:\n\n      - `fnEqual` - whether all functions are considered equal (default: yes)\n      - `depth` - how deep to recurse until treating as equal (default: 5)\n*/\nfunction isApproxEqual(x, y, opts) {\n  opts = opts || {};\n  var fnEqual = opts.fnEqual !== false;\n  var depth = opts.depth || 5; // totally arbitrary\n\n  // state contains pairs we checked (or are still checking, but assume equal!)\n  var state = [];\n\n  function loop(a, b, n) {\n    if (isNaN(a) && isNaN(b)) {\n      return true;\n    }\n\n    // trivial check\n    if (a === b) {\n      return true;\n    }\n\n    // depth check\n    if (n >= depth) {\n      return true;\n    }\n\n    var i;\n\n    // check if pair already occured\n    for (i = 0; i < state.length; i++) {\n      if (state[i][0] === a && state[i][1] === b) {\n        return true;\n      }\n    }\n\n    // add to state\n    state.push([a, b]);\n\n    if (typeof a === \"function\" && typeof b === \"function\") {\n      return fnEqual;\n    }\n\n    if (isArray(a) && isArray(b) && a.length === b.length) {\n      for (i = 0; i < a.length; i++) {\n        if (!loop(a[i], b[i], n + 1)) {\n          return false;\n        }\n      }\n      return true;\n    } else if (isObject(a) && isObject(b) && !isArray(a) && !isArray(b)) {\n      var akeys = Object.keys(a);\n      var bkeys = Object.keys(b);\n      if (!loop(sort(akeys), sort(bkeys), n + 1)) {\n        return false;\n      }\n\n      for (i = 0; i < akeys.length; i++) {\n        if (!loop(a[akeys[i]], b[akeys[i]], n + 1)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    return false;\n  }\n  return loop(x, y, 0);\n}\n\nfunction identity(x) {\n  return x;\n}\n\nfunction pluck(arr, key) {\n  return arr.map(function (e) {\n    return e[key];\n  });\n}\n\n/**\n  - `utils.force(x: a | () -> a) : a`\n\n      Evaluate `x` as nullary function, if it is one.\n*/\nfunction force(arb) {\n  return (typeof arb === \"function\") ? arb() : arb;\n}\n\n/**\n  - `utils.merge(x... : obj): obj`\n\n    Merge two objects, a bit like `_.extend({}, x, y)`.\n*/\nfunction merge() {\n  var res = {};\n\n  for (var i = 0; i < arguments.length; i++) {\n    var arg = arguments[i];\n    var keys = Object.keys(arg);\n    for (var j = 0; j < keys.length; j++) {\n      var key = keys[j];\n      res[key] = arg[key];\n    }\n  }\n\n  return res;\n}\n\nfunction div2(x) {\n  return Math.floor(x / 2);\n}\n\nfunction log2(x) {\n  return Math.log(x) / Math.log(2);\n}\n\nfunction ilog2(x) {\n  return x <= 0 ? 0 : Math.floor(log2(x));\n}\n\nfunction curriedN(n) {\n  var n1 = n - 1;\n  return function curriedNInstance(result, args) {\n    if (args.length === n) {\n      return result(args[n1]);\n    } else {\n      return result;\n    }\n  };\n}\n\nvar curried2 = curriedN(2);\nvar curried3 = curriedN(3);\n\nfunction charArrayToString(arr) {\n  return arr.join(\"\");\n}\n\nfunction stringToCharArray(str) {\n  return str.split(\"\");\n}\n\nfunction pairArrayToDict(arrayOfPairs) {\n  var res = {};\n  arrayOfPairs.forEach(function (p) {\n    res[p[0]] = p[1];\n  });\n  return res;\n}\n\nfunction dictToPairArray(m) {\n  var res = [];\n  Object.keys(m).forEach(function (k) {\n    res.push([k, m[k]]);\n  });\n  return res;\n}\n\nfunction partition(arr, pred) {\n  var truthy = [];\n  var falsy = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    var x = arr[i];\n    if (pred(x)) {\n      truthy.push(x);\n    } else {\n      falsy.push(x);\n    }\n  }\n\n  return [truthy, falsy];\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isObject: isObject,\n  isEqual: isEqual,\n  isApproxEqual: isApproxEqual,\n  identity: identity,\n  pluck: pluck,\n  force: force,\n  merge: merge,\n  div2: div2,\n  ilog2: ilog2,\n  curried2: curried2,\n  curried3: curried3,\n  charArrayToString: charArrayToString,\n  stringToCharArray: stringToCharArray,\n  pairArrayToDict: pairArrayToDict,\n  dictToPairArray: dictToPairArray,\n  partition: partition,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/array.js":"\"use strict\";\n\nvar arbitraryAssert = require(\"./arbitraryAssert.js\");\nvar arbitraryBless = require(\"./arbitraryBless.js\");\nvar generator = require(\"./generator.js\");\nvar show = require(\"./show.js\");\nvar shrink = require(\"./shrink.js\");\nvar utils = require(\"./utils.js\");\n\nfunction makeArray(flavour) {\n  return function arrayImpl(arb) {\n    arb = utils.force(arb);\n\n    arbitraryAssert(arb);\n\n    return arbitraryBless({\n      generator: generator[flavour](arb.generator),\n      shrink: shrink[flavour](arb.shrink),\n      show: show.array(arb.show),\n    });\n  };\n}\n\nvar array = makeArray(\"array\");\nvar nearray = makeArray(\"nearray\");\n\nmodule.exports = {\n  array: array,\n  nearray: nearray,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/generator.js":"/* @flow weak */\n\"use strict\";\n\nvar assert = require(\"assert\");\nvar either = require(\"./either.js\");\nvar random = require(\"./random.js\");\nvar sum = require(\"./sum.js\");\nvar utils = require(\"./utils.js\");\n\n/**\n  ### Generator functions\n\n  A generator function, `generator a`, is a function `(size: nat) -> a`, which generates a value of given size.\n\n  Generator combinators are auto-curried:\n\n  ```js\n  var xs = jsc.generator.array(jsc.nat.generator, 1); // \n  var ys = jsc.generator.array(jsc.nat.generator)(1);\n  ```\n\n  In purely functional approach `generator a` would be explicitly stateful computation:\n  `(size: nat, rng: randomstate) -> (a, randomstate)`.\n  *JSVerify* uses an implicit random number generator state,\n  but the value generation is deterministic (tests are reproducible),\n  if the primitives from *random* module are used.\n*/\n\n// Blessing: i.e adding prototype\n/* eslint-disable no-use-before-define */\nfunction generatorProtoMap(f) {\n  /* jshint validthis:true */\n  var generator = this; // eslint-disable-line no-invalid-this\n  generatorAssert(generator);\n  return generatorBless(function (size) {\n    return f(generator(size));\n  });\n}\n\nfunction generatorProtoFlatMap(f) {\n  /* jshint validthis:true */\n  var generator = this; // eslint-disable-line no-invalid-this\n  generatorAssert(generator);\n  return generatorBless(function (size) {\n    return f(generator(size))(size);\n  });\n}\n/* eslint-enable no-use-before-define */\n\nfunction generatorAssert(generator) {\n  assert(typeof generator === \"function\", \"generator should be a function\");\n  assert(generator.map === generatorProtoMap, \"generator.map should be a function\");\n  assert(generator.flatmap === generatorProtoFlatMap, \"generator.flatmap should be a function\");\n  assert(generator.flatMap === generatorProtoFlatMap, \"generator.flatMap should be a function\");\n}\n\n/**\n  - `generator.bless(f: nat -> a): generator a`\n\n      Bless function with `.map` and `.flatmap` properties.\n\n  - `.map(f: a -> b): generator b`\n\n      Map `generator a` into `generator b`. For example:\n\n      ```js\n      positiveIntegersGenerator = nat.generator.map(\n        function (x) { return x + 1; });\n      ```\n\n  - `.flatmap(f: a -> generator b): generator b`\n\n      Monadic bind for generators. Also `flatMap` version is supported.\n*/\nfunction generatorBless(generator) {\n  generator.map = generatorProtoMap;\n  generator.flatmap = generatorProtoFlatMap;\n  generator.flatMap = generatorProtoFlatMap;\n  return generator;\n}\n\n/**\n  - `generator.constant(x: a): generator a`\n*/\nfunction generateConstant(x) {\n  return generatorBless(function () {\n    return x;\n  });\n}\n\n/**\n  - `generator.combine(gen: generator a..., f: a... -> b): generator b`\n*/\nfunction generatorCombine() {\n  var generators = Array.prototype.slice.call(arguments, 0, -1);\n  var f = arguments[arguments.length - 1];\n\n  return generatorBless(function (size) {\n    var values = generators.map(function (gen) {\n      return gen(size);\n    });\n\n    return f.apply(undefined, values);\n  });\n}\n\n/**\n  - `generator.oneof(gens: list (generator a)): generator a`\n*/\nfunction generateOneof(generators) {\n  // TODO: generator\n  generators.forEach(function (gen) {\n    assert(typeof gen === \"function\");\n  });\n\n  var result = generatorBless(function (size) {\n    var idx = random(0, generators.length - 1);\n    var gen = generators[idx];\n    return gen(size);\n  });\n\n  return utils.curried2(result, arguments);\n}\n\n// Helper, essentially: log2(size + 1)\nfunction logsize(size) {\n  return Math.max(Math.round(Math.log(size + 1) / Math.log(2), 0));\n}\n\n/**\n  - `generator.recursive(genZ: generator a, genS: generator a -> generator a): generator a`\n*/\nfunction generatorRecursive(genZ, genS) {\n  return generatorBless(function (size) {\n    function rec(n, sizep) {\n      if (n <= 0 || random(0, 3) === 0) {\n        return genZ(sizep);\n      } else {\n        return genS(generatorBless(function (sizeq) {\n          return rec(n - 1, sizeq);\n        }))(sizep);\n      }\n    }\n\n    return rec(logsize(size), size);\n  });\n}\n\n/**\n  - `generator.pair(genA: generator a, genB: generator b): generator (a, b)`\n*/\nfunction generatePair(genA, genB) {\n  var result = generatorBless(function (size) {\n    return [genA(size), genB(size)];\n  });\n\n  return utils.curried3(result, arguments);\n}\n\n/**\n  - `generator.either(genA: generator a, genB: generator b): generator (either a b)`\n*/\nfunction generateEither(genA, genB) {\n  var result = generatorBless(function (size) { // eslint-disable-line consistent-return\n    var n = random(0, 1);\n    switch (n) {\n      case 0: return either.left(genA(size));\n      case 1: return either.right(genB(size));\n      // no default\n    }\n  });\n\n  return utils.curried3(result, arguments);\n}\n/**\n  - `generator.unit: generator ()`\n\n      `unit` is an empty tuple, i.e. empty array in JavaScript representation. This is useful as a building block.\n*/\nvar generateUnit = generatorBless(function () {\n  return [];\n});\n\n/**\n  - `generator.tuple(gens: (generator a, generator b...)): generator (a, b...)`\n*/\nfunction generateTuple(gens) {\n  var len = gens.length;\n  var result = generatorBless(function (size) {\n    var r = [];\n    for (var i = 0; i < len; i++) {\n      r[i] = gens[i](size);\n    }\n    return r;\n  });\n\n  return utils.curried2(result, arguments);\n}\n\n/**\n  - `generator.sum(gens: (generator a, generator b...)): generator (a | b...)`\n*/\nfunction generateSum(gens) {\n  var len = gens.length;\n  var result = generatorBless(function (size) {\n    var idx = random(0, len - 1);\n    return sum.addend(idx, len, gens[idx](size));\n  });\n\n  return utils.curried2(result, arguments);\n}\n\n/**\n   - `generator.array(gen: generator a): generator (array a)`\n*/\nfunction generateArray(gen) {\n  var result = generatorBless(function (size) {\n    var arrsize = random(0, logsize(size));\n    var arr = new Array(arrsize);\n    for (var i = 0; i < arrsize; i++) {\n      arr[i] = gen(size);\n    }\n    return arr;\n  });\n\n  return utils.curried2(result, arguments);\n}\n\n/**\n   - `generator.nearray(gen: generator a): generator (array a)`\n*/\nfunction generateNEArray(gen) {\n  var result = generatorBless(function (size) {\n    var arrsize = random(1, Math.max(logsize(size), 1));\n    var arr = new Array(arrsize);\n    for (var i = 0; i < arrsize; i++) {\n      arr[i] = gen(size);\n    }\n    return arr;\n  });\n\n  return utils.curried2(result, arguments);\n}\n\n/**\n  - `generator.dict(gen: generator a): generator (dict a)`\n*/\n\nmodule.exports = {\n  pair: generatePair,\n  either: generateEither,\n  unit: generateUnit,\n  tuple: generateTuple,\n  sum: generateSum,\n  array: generateArray,\n  nearray: generateNEArray,\n  oneof: generateOneof,\n  constant: generateConstant,\n  bless: generatorBless,\n  combine: generatorCombine,\n  recursive: generatorRecursive,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/either.js":"\"use strict\";\n\nvar assert = require(\"assert\");\n\n/**\n  ### either\n*/\n\nfunction Left(value) {\n  this.value = value;\n}\n\nfunction Right(value) {\n  this.value = value;\n}\n\n/**\n  - `either.left(value: a): either a b`\n*/\nfunction left(value) {\n  return new Left(value);\n}\n\n/**\n  - `either.right(value: b): either a b`\n*/\nfunction right(value) {\n  return new Right(value);\n}\n\n/**\n  - `either.either(l: a -> x, r: b -> x): x`\n*/\nLeft.prototype.either = function lefteither(l) {\n  return l(this.value);\n};\n\nRight.prototype.either = function righteither(l, r) {\n  return r(this.value);\n};\n\n/**\n  - `either.isEqual(other: either a b): bool`\n\n      TODO: add `eq` optional parameter\n*/\nLeft.prototype.isEqual = function leftIsEqual(other) {\n  assert(other instanceof Left || other instanceof Right, \"isEqual: `other` parameter should be either\");\n  return other instanceof Left && this.value === other.value;\n};\n\nRight.prototype.isEqual = function rightIsEqual(other) {\n  assert(other instanceof Left || other instanceof Right, \"isEqual: `other` parameter should be either\");\n  return other instanceof Right && this.value === other.value;\n};\n\n/**\n  - `either.bimap(f: a -> c, g: b -> d): either c d`\n\n      ```js\n      either.bimap(compose(f, g), compose(h, i))  either.bimap(g, i).bimap(f, h);\n      ```\n\n*/\nLeft.prototype.bimap = function leftBimap(f) {\n  return new Left(f(this.value));\n};\n\nRight.prototype.bimap = function rightBimap(f, g) {\n  return new Right(g(this.value));\n};\n\n/**\n  - `either.first(f: a -> c): either c b`\n\n      ```js\n      either.first(f)  either.bimap(f, utils.identity)\n      ```\n*/\nLeft.prototype.first = function leftFirst(f) {\n  return new Left(f(this.value));\n};\n\nRight.prototype.first = function rightFirst() {\n  return this;\n};\n\n/**\n  - `either.second(g: b -> d): either a d`\n\n      ```js\n      either.second(g) === either.bimap(utils.identity, g)\n      ```\n*/\nLeft.prototype.second = function leftSecond() {\n  return this;\n};\n\nRight.prototype.second = function rightSecond(g) {\n  return new Right(g(this.value));\n};\n\nmodule.exports = {\n  left: left,\n  right: right,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/random.js":"/* @flow weak */\n\"use strict\";\n\nvar rc4 = new (require(\"rc4\").RC4small)();\n\n/**\n  ### Random functions\n*/\n\n/**\n  - `random(min: int, max: int): int`\n\n      Returns random int from `[min, max]` range inclusively.\n\n      ```js\n      getRandomInt(2, 3) // either 2 or 3\n      ```\n*/\nfunction randomInteger(min, max) {\n  return rc4.random(min, max);\n}\n\n/**\n  - `random.number(min: number, max: number): number`\n\n      Returns random number from `[min, max)` range.\n*/\nfunction randomNumber(min, max) {\n  return rc4.randomFloat() * (max - min) + min;\n}\n\nrandomInteger.integer = randomInteger;\nrandomInteger.number = randomNumber;\n\nrandomInteger.currentStateString = rc4.currentStateString.bind(rc4);\nrandomInteger.setStateString = rc4.setStateString.bind(rc4);\n\nmodule.exports = randomInteger;\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/sum.js":"\"use strict\";\n\nvar assert = require(\"assert\");\n\n/**\n  ### sum (n-ary either)\n\n  See: [Wikipedia](https://en.wikipedia.org/wiki/Tagged_union)\n*/\n\nfunction Addend(idx, len, value) {\n  assert(len > 0, \"Addend: 0 < len\"); // empty sum is void - cannot create such\n  assert(idx >= 0 && idx < len, \"Addend: 0 <= idx < len\");\n  this.idx = idx;\n  this.len = len;\n  this.value = value;\n}\n\n/**\n  - `sum.addend(idx: nat, n: nat, value: a): sum (... a ...)`\n*/\nfunction addend(idx, len, value) {\n  return new Addend(idx, len, value);\n}\n\n/**\n  - `.fold(f: (idx: nat, n: nat, value: a) -> b): b`\n*/\nAddend.prototype.fold = function (f) {\n  return f(this.idx, this.len, this.value);\n};\n\nmodule.exports = {\n  addend: addend,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/shrink.js":"/* @flow weak */\n\"use strict\";\n\nvar assert = require(\"assert\");\nvar either = require(\"./either.js\");\nvar lazyseq = require(\"lazy-seq\");\nvar sum = require(\"./sum.js\");\nvar utils = require(\"./utils.js\");\n\n/**\n  ### Shrink functions\n\n  A shrink function, `shrink a`, is a function `a -> [a]`, returning an array of *smaller* values.\n\n  Shrink combinators are auto-curried:\n\n  ```js\n  var xs = jsc.shrink.array(jsc.nat.shrink, [1]); // \n  var ys = jsc.shrink.array(jsc.nat.shrink)([1]);\n  ```\n*/\n\n// Blessing: i.e adding prototype\n/* eslint-disable no-use-before-define */\nfunction shrinkProtoIsoMap(f, g) {\n  /* jshint validthis:true */\n  var shrink = this; // eslint-disable-line no-invalid-this\n  return shrinkBless(function (value) {\n    return shrink(g(value)).map(f);\n  });\n}\n/* eslint-enable no-use-before-define */\n\n/**\n  - `shrink.bless(f: a -> [a]): shrink a`\n\n      Bless function with `.smap` property.\n\n  - `.smap(f: a -> b, g: b -> a): shrink b`\n\n      Transform `shrink a` into `shrink b`. For example:\n\n      ```js\n      positiveIntegersShrink = nat.shrink.smap(\n        function (x) { return x + 1; },\n        function (x) { return x - 1; });\n      ```\n*/\nfunction shrinkBless(shrink) {\n  shrink.smap = shrinkProtoIsoMap;\n  return shrink;\n}\n\n/**\n  - `shrink.noop: shrink a`\n*/\nvar shrinkNoop = shrinkBless(function shrinkNoop() {\n  return [];\n});\n\n/**\n  - `shrink.pair(shrA: shrink a, shrB: shrink b): shrink (a, b)`\n*/\nfunction shrinkPair(shrinkA, shrinkB) {\n  var result = shrinkBless(function (pair) {\n    assert(pair.length === 2, \"shrinkPair: pair should be an Array of length 2\");\n\n    var a = pair[0];\n    var b = pair[1];\n\n    var shrinkedA = shrinkA(a);\n    var shrinkedB = shrinkB(b);\n\n    var pairA = shrinkedA.map(function (ap) {\n      return [ap, b];\n    });\n\n    if (Array.isArray(pairA)) {\n      pairA = lazyseq.fromArray(pairA);\n    }\n\n    return pairA.append(function () {\n      var pairB = shrinkedB.map(function (bp) {\n        return [a, bp];\n      });\n      return pairB;\n    });\n  });\n\n  return utils.curried3(result, arguments);\n}\n\n/**\n  - `shrink.either(shrA: shrink a, shrB: shrink b): shrink (either a b)`\n*/\nfunction shrinkEither(shrinkA, shrinkB) {\n  function shrinkLeft(value) {\n    return shrinkA(value).map(either.left);\n  }\n\n  function shrinkRight(value) {\n    return shrinkB(value).map(either.right);\n  }\n\n  var result = shrinkBless(function (e) {\n    return e.either(shrinkLeft, shrinkRight);\n  });\n\n  return utils.curried3(result, arguments);\n}\n\n// We represent non-empty linked list as\n// singl x = [x]\n// cons h t = [h, t]\nfunction fromLinkedList(ll) {\n  assert(ll.length === 1 || ll.length === 2, \"linked list must be either [] or [x, linkedlist]\");\n  if (ll.length === 1) {\n    return [ll[0]];\n  } else {\n    return [ll[0]].concat(fromLinkedList(ll[1]));\n  }\n}\n\nfunction toLinkedList(arr) {\n  assert(Array.isArray(arr) && arr.length > 0, \"toLinkedList expects non-empty array\");\n  if (arr.length === 1) {\n    return [arr[0]];\n  } else {\n    return [arr[0], toLinkedList(arr.slice(1))];\n  }\n}\n\nfunction toSingleton(x) {\n  return [x];\n}\n\n// Vec a 1  a\nfunction fromSingleton(a) {\n  return a[0];\n}\n\nfunction flattenShrink(shrinksLL) {\n  if (shrinksLL.length === 1) {\n    return shrinksLL[0].smap(toSingleton, fromSingleton);\n  } else {\n    var head = shrinksLL[0];\n    var tail = shrinksLL[1];\n    return shrinkPair(head, flattenShrink(tail));\n  }\n}\n\n/**\n  - `shrink.tuple(shrs: (shrink a, shrink b...)): shrink (a, b...)`\n*/\nfunction shrinkTuple(shrinks) {\n  assert(shrinks.length > 0, \"shrinkTuple needs > 0 values\");\n  var shrinksLL = toLinkedList(shrinks);\n  var shrink = flattenShrink(shrinksLL);\n  var result = shrinkBless(function (tuple) {\n    assert(tuple.length === shrinks.length, \"shrinkTuple: not-matching params\");\n    var ll = toLinkedList(tuple);\n    return shrink(ll).map(fromLinkedList);\n  });\n\n  return utils.curried2(result, arguments);\n}\n\n/**\n  - `shrink.sum(shrs: (shrink a, shrink b...)): shrink (a | b...)`\n*/\nfunction shrinkSum(shrinks) {\n  assert(shrinks.length > 0, \"shrinkTuple needs > 0 values\");\n  var result = shrinkBless(function (s) {\n    return s.fold(function (idx, len, value) {\n      assert(len === shrinks.length, \"shrinkSum: not-matching params\");\n      return shrinks[idx](value).map(function (shrinked) {\n        return sum.addend(idx, len, shrinked);\n      });\n    });\n  });\n\n  return utils.curried2(result, arguments);\n}\n\nfunction shrinkArrayWithMinimumSize(size) {\n  function shrinkArrayImpl(shrink) {\n    var result = shrinkBless(function (arr) {\n      assert(Array.isArray(arr), \"shrinkArrayImpl() expects array, got: \" + arr);\n      if (arr.length <= size) {\n        return lazyseq.nil;\n      } else {\n        var x = arr[0];\n        var xs = arr.slice(1);\n\n        return lazyseq.cons(xs, lazyseq.nil)\n          .append(shrink(x).map(function (xp) { return [xp].concat(xs); }))\n          .append(shrinkArrayImpl(shrink, xs).map(function (xsp) { return [x].concat(xsp); }));\n      }\n    });\n\n    return utils.curried2(result, arguments);\n  }\n\n  return shrinkArrayImpl;\n}\n\n/**\n  - `shrink.array(shr: shrink a): shrink (array a)`\n*/\nvar shrinkArray = shrinkArrayWithMinimumSize(0);\n\n/**\n  - `shrink.nearray(shr: shrink a): shrink (nearray a)`\n*/\nvar shrinkNEArray = shrinkArrayWithMinimumSize(1);\n\nmodule.exports = {\n  noop: shrinkNoop,\n  pair: shrinkPair,\n  either: shrinkEither,\n  tuple: shrinkTuple,\n  sum: shrinkSum,\n  array: shrinkArray,\n  nearray: shrinkNEArray,\n  bless: shrinkBless,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/dict.js":"/* @flow weak */\n\"use strict\";\n\nvar arbitraryAssert = require(\"./arbitraryAssert.js\");\nvar array = require(\"./array.js\");\nvar generator = require(\"./generator.js\");\nvar pair = require(\"./pair.js\");\nvar string = require(\"./string.js\");\nvar utils = require(\"./utils.js\");\n\nfunction makeMapShow(elShow) {\n  return function (m) {\n    return \"{\" + Object.keys(m).map(function (k) {\n      return k + \": \" + elShow(m[k]);\n    }).join(\", \") + \"}\";\n  };\n}\n\n/**\n  - `dict.generator(gen: generator a): generator (dict a)`\n*/\nfunction generateDict(gen) {\n  var pairGen = generator.pair(string.string.generator, gen);\n  var arrayGen = generator.array(pairGen);\n  var result = arrayGen.map(utils.pairArrayToDict);\n\n  return utils.curried2(result, arguments);\n}\n\nfunction dict(arb) {\n  arb = utils.force(arb);\n  arbitraryAssert(arb);\n\n  var pairArbitrary = pair.pair(string.string, arb);\n  var arrayArbitrary = array.array(pairArbitrary);\n\n  return arrayArbitrary.smap(utils.pairArrayToDict, utils.dictToPairArray, makeMapShow(arb.show));\n}\n\nmodule.exports = {\n  arbitrary: dict,\n  generator: generateDict,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/pair.js":"\"use strict\";\n\nvar arbitraryAssert = require(\"./arbitraryAssert.js\");\nvar arbitraryBless = require(\"./arbitraryBless.js\");\nvar generator = require(\"./generator.js\");\nvar show = require(\"./show.js\");\nvar shrink = require(\"./shrink.js\");\nvar utils = require(\"./utils.js\");\n\nfunction pair(a, b) {\n  a = utils.force(a);\n  b = utils.force(b);\n\n  arbitraryAssert(a);\n  arbitraryAssert(b);\n\n  return arbitraryBless({\n    generator: generator.pair(a.generator, b.generator),\n    shrink: shrink.pair(a.shrink, b.shrink),\n    show: show.pair(a.show, b.show),\n  });\n}\n\nmodule.exports = {\n  pair: pair,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/string.js":"\"use strict\";\n\nvar array = require(\"./array.js\");\nvar primitive = require(\"./primitive.js\");\nvar utils = require(\"./utils.js\");\n\n/**\n  ### Arbitrary strings\n*/\n\nfunction fromCode(code) {\n  return String.fromCharCode(code);\n}\n\nfunction toCode(c) {\n  return c.charCodeAt(0);\n}\n\n/**\n  - `char: arbitrary char` &mdash; Single character\n*/\nvar char = primitive.nat(0xff).smap(fromCode, toCode);\n\n/**\n  - `asciichar: arbitrary char` &mdash; Single ascii character (0x20-0x7e inclusive, no DEL)\n*/\nvar asciichar = primitive.integer(0x20, 0x7e).smap(fromCode, toCode);\n\n/**\n  - `string: arbitrary string`\n*/\nvar string = array.array(char).smap(utils.charArrayToString, utils.stringToCharArray);\n\n/**\n  - `nestring: arbitrary string` &mdash; Generates strings which are not empty.\n*/\nvar nestring = array.nearray(char).smap(utils.charArrayToString, utils.stringToCharArray);\n\n/**\n  - `asciistring: arbitrary string`\n*/\nvar asciistring = array.array(asciichar).smap(utils.charArrayToString, utils.stringToCharArray);\n\n/**\n  - `asciinestring: arbitrary string`\n*/\nvar asciinestring = array.nearray(asciichar).smap(utils.charArrayToString, utils.stringToCharArray);\n\nmodule.exports = {\n  char: char,\n  asciichar: asciichar,\n  string: string,\n  nestring: nestring,\n  asciistring: asciistring,\n  asciinestring: asciinestring,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/primitive.js":"/* @flow weak */\n\"use strict\";\n\nvar arbitraryBless = require(\"./arbitraryBless\");\nvar assert = require(\"assert\");\nvar generator = require(\"./generator.js\");\nvar random = require(\"./random.js\");\nvar show = require(\"./show.js\");\nvar shrink = require(\"./shrink.js\");\nvar utils = require(\"./utils.js\");\n\n/**\n  ### Primitive arbitraries\n*/\n\nfunction extendWithDefault(arb) {\n  var def = arb();\n  arb.generator = def.generator;\n  arb.shrink = def.shrink;\n  arb.show = def.show;\n  arb.smap = def.smap;\n}\n\nfunction numeric(impl) {\n  return function (minsize, maxsize) {\n    if (arguments.length === 2) {\n      var arb = arbitraryBless(impl(maxsize - minsize));\n      var to = function to(x) {\n        return Math.abs(x) + minsize;\n      };\n      var from = function from(x) {\n        return x - minsize;\n      };\n\n      return arb.smap(to, from);\n    } else if (arguments.length === 1) {\n      return arbitraryBless(impl(minsize /* as maxsize */));\n    } else {\n      return arbitraryBless(impl());\n    }\n  };\n}\n\n/**\n  - `integer: arbitrary integer`\n  - `integer(maxsize: nat): arbitrary integer`\n  - `integer(minsize: integer, maxsize: integer): arbitrary integer`\n\n      Integers, \n*/\nvar integer = numeric(function integer(maxsize) {\n  return {\n    generator: generator.bless(function (size) {\n      size = maxsize === undefined ? size : maxsize;\n      return random(-size, size);\n    }),\n    shrink: shrink.bless(function (i) {\n      assert(typeof i === \"number\", \"integer.shrink have to be a number\");\n\n      i = Math.abs(i);\n      if (i === 0) {\n        return [];\n      } else {\n        var arr = [0];\n        var j = utils.div2(i);\n        var k = Math.max(j, 1);\n        while (j < i) {\n          arr.push(j);\n          arr.push(-j);\n          k = Math.max(utils.div2(k), 1);\n          j += k;\n        }\n        return arr;\n      }\n    }),\n\n    show: show.def,\n  };\n});\n\nextendWithDefault(integer);\n\n/**\n  - `nat: arbitrary nat`\n  - `nat(maxsize: nat): arbitrary nat`\n\n      Natural numbers,  (0, 1, 2...)\n*/\nfunction nat(maxsize) {\n  return arbitraryBless({\n    generator: generator.bless(function (size) {\n      size = maxsize === undefined ? size : maxsize;\n      return random(0, size);\n    }),\n    shrink: shrink.bless(function (i) {\n      assert(typeof i === \"number\", \"nat.shrink have to be a number\");\n\n      var arr = [];\n      var j = utils.div2(i);\n      var k = Math.max(j, 1);\n      while (j < i) {\n        arr.push(j);\n        k = Math.max(utils.div2(k), 1);\n        j += k;\n      }\n      return arr;\n    }),\n    show: show.def,\n  });\n}\n\nextendWithDefault(nat);\n\n/**\n  - `number: arbitrary number`\n  - `number(maxsize: number): arbitrary number`\n  - `number(min: number, max: number): arbitrary number`\n\n      JavaScript numbers, \"doubles\", . `NaN` and `Infinity` are not included.\n*/\nvar number = numeric(function number(maxsize) {\n  return {\n    generator: generator.bless(function (size) {\n      size = maxsize === undefined ? size : maxsize;\n      return random.number(-size, size);\n    }),\n    shrink: shrink.bless(function (x) {\n      assert(typeof x === \"number\", \"number.shrink have to be a number\");\n\n      if (Math.abs(x) > 1e-6) {\n        return [0, x / 2, -x / 2];\n      } else {\n        return [];\n      }\n    }),\n    show: show.def,\n  };\n});\n\nextendWithDefault(number);\n\n/**\n  - `uint8: arbitrary nat`\n  - `uint16: arbitrary nat`\n  - `uint32: arbitrary nat`\n*/\nvar uint8 = nat(0xff);\nvar uint16 = nat(0xffff);\nvar uint32 = nat(0xffffffff);\n\n/**\n  - `int8: arbitrary integer`\n  - `int16: arbitrary integer`\n  - `int32: arbitrary integer`\n*/\nvar int8 = integer(-0x80, 0x7f);\nvar int16 = integer(-0x8000, 0x7fff);\nvar int32 = integer(-0x80000000, 0x7fffffff);\n\n/**\n  - `bool: arbitrary bool`\n\n      Booleans, `true` or `false`.\n*/\nvar bool = arbitraryBless({\n  generator: generator.bless(function (/* size */) {\n    var i = random(0, 1);\n    return i === 1;\n  }),\n\n  shrink: shrink.bless(function (b) {\n    assert(b === true || b === false, \"bool.shrink excepts true or false\");\n    return b === true ? [false] : [];\n  }),\n  show: show.def,\n});\n\n/**\n  - `datetime: arbitrary datetime`\n\n      Random datetime\n*/\nvar datetimeConst = 1416499879495; // arbitrary datetime\n\nfunction datetime(from, to) {\n  var toDate;\n  var fromDate;\n  var arb;\n\n  if (arguments.length === 2) {\n    toDate = function toDateFn(x) {\n      return new Date(x);\n    };\n    fromDate = function fromDateFn(x) {\n      return x.getTime();\n    };\n    from = fromDate(from);\n    to = fromDate(to);\n    arb = number(from, to);\n\n    return arb.smap(toDate, fromDate);\n  } else {\n    toDate = function toDateFn(x) {\n      return new Date(x * 768000000 + datetimeConst);\n    };\n    arb = number;\n\n    return arbitraryBless({\n      generator: arb.generator.map(toDate),\n      shrink: shrink.noop,\n      show: show.def,\n    });\n  }\n}\n\nextendWithDefault(datetime);\n\n/**\n  - `elements(args: array a): arbitrary a`\n\n      Random element of `args` array.\n*/\nfunction elements(args) {\n  assert(args.length !== 0, \"elements: at least one parameter expected\");\n\n  return arbitraryBless({\n    generator: generator.bless(function (/* size */) {\n      var i = random(0, args.length - 1);\n      return args[i];\n    }),\n\n    shrink: shrink.bless(function (x) {\n      var idx = args.indexOf(x);\n      if (idx <= 0) {\n        return [];\n      } else {\n        return args.slice(0, idx);\n      }\n    }),\n    show: show.def,\n  });\n}\n\n/**\n  - `falsy: arbitrary *`\n\n      Generates falsy values: `false`, `null`, `undefined`, `\"\"`, `0`, and `NaN`.\n*/\nvar falsy = elements([false, null, undefined, \"\", 0, NaN]);\nfalsy.show = function (v) {\n  if (v !== v) {\n    return \"falsy: NaN\";\n  } else if (v === \"\") {\n    return \"falsy: empty string\";\n  } else if (v === undefined) {\n    return \"falsy: undefined\";\n  } else {\n    return \"falsy: \" + v;\n  }\n};\n\n/**\n  - `constant(x: a): arbitrary a`\n\n      Returns an unshrinkable arbitrary that yields the given object.\n*/\nfunction constant(x) {\n  return arbitraryBless({\n    generator: generator.constant(x),\n    shrink: shrink.noop,\n    show: show.def,\n  });\n}\n\nmodule.exports = {\n  integer: integer,\n  nat: nat,\n  int8: int8,\n  int16: int16,\n  int32: int32,\n  uint8: uint8,\n  uint16: uint16,\n  uint32: uint32,\n  number: number,\n  elements: elements,\n  bool: bool,\n  falsy: falsy,\n  constant: constant,\n  datetime: datetime,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/json.js":"\"use strict\";\n\nvar assert = require(\"assert\");\n\nvar arbitraryBless = require(\"./arbitraryBless.js\");\nvar dict = require(\"./dict.js\");\nvar generator = require(\"./generator.js\");\nvar primitive = require(\"./primitive.js\");\nvar show = require(\"./show.js\");\nvar shrink = require(\"./shrink.js\");\nvar string = require(\"./string.js\");\nvar utils = require(\"./utils.js\");\n\nvar nullArb = primitive.constant(null);\n\nvar generateInteger = primitive.integer.generator;\nvar generateNumber = primitive.number.generator;\nvar generateBool = primitive.bool.generator;\nvar generateString = string.string.generator;\nvar generateNull = nullArb.generator;\n\nvar generateJson = generator.recursive(\n  generator.oneof([\n    generateInteger,\n    generateNumber,\n    generateBool,\n    generateString,\n    generateNull,\n  ]),\n  function (gen) {\n    return generator.oneof([generator.array(gen), dict.generator(gen)]);\n  });\n\n// Forward declaration\nvar shrinkDictJson;\nvar shrinkJson;\n\nfunction shrinkRecJson(json) {\n  if (Array.isArray(json)) {\n    return shrink.array(shrinkJson, json);\n  } else {\n    return shrinkDictJson(json);\n  }\n}\n\nshrinkJson = shrink.bless(function (json) {\n  assert(typeof json !== \"function\");\n\n  if (json === null) {\n    return nullArb.shrink(json);\n  }\n\n  switch (typeof json) {\n    case \"boolean\": return primitive.bool.shrink(json);\n    case \"number\": return primitive.number.shrink(json);\n    case \"string\": return string.string.shrink(json);\n    default: return shrinkRecJson(json);\n  }\n});\n\nshrinkDictJson = (function () {\n  var pairShrink = shrink.pair(string.string.shrink, shrinkJson);\n  var arrayShrink = shrink.array(pairShrink);\n\n  return arrayShrink.smap(utils.pairArrayToDict, utils.dictToPairArray);\n}());\n\nvar json = arbitraryBless({\n  generator: generateJson,\n  shrink: shrinkJson,\n  show: show.def,\n});\n\nmodule.exports = {\n  json: json,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/bless.js":"\"use strict\";\n\nvar assert = require(\"assert\");\n\nvar arbitraryBless = require(\"./arbitraryBless.js\");\nvar generator = require(\"./generator.js\");\nvar show = require(\"./show.js\");\nvar shrink = require(\"./shrink.js\");\n\n/**\n  - `bless(arb: {...}): arbitrary a`\n\n    Bless almost arbitrary structure to be proper arbitrary. *Note*: this function mutates argument.\n\n    #### Example:\n\n    ```js\n    var arbTokens = jsc.bless({\n      generator: function () {\n        switch (jsc.random(0, 2)) {\n          case 0: return \"foo\";\n          case 1: return \"bar\";\n          case 2: return \"quux\";\n        }\n      }\n    });\n    ```\n*/\nfunction bless(arb) {\n  assert(arb !== null && typeof arb === \"object\", \"bless: arb should be an object\");\n  assert(typeof arb.generator === \"function\", \"bless: arb.generator should be a function\");\n\n  // default shrink\n  if (typeof arb.shrink !== \"function\") {\n    arb.shrink = shrink.noop;\n  }\n\n  // default show\n  if (typeof arb.show !== \"function\") {\n    arb.show = show.def;\n  }\n\n  generator.bless(arb.generator);\n  shrink.bless(arb.shrink);\n\n  arbitraryBless(arb);\n  return arb;\n}\n\nmodule.exports = bless;\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/record.js":"\"use strict\";\n\nvar arbitraryBless = require(\"./arbitraryBless.js\");\nvar generator = require(\"./generator.js\");\nvar utils = require(\"./utils.js\");\nvar shrink = require(\"./shrink.js\");\n\n/**\n  - `generator.record(gen: { key: generator a... }): generator { key: a... }`\n*/\nfunction generatorRecord(spec) {\n  var keys = Object.keys(spec);\n  var result = generator.bless(function (size) {\n    var res = {};\n    keys.forEach(function (k) {\n      res[k] = spec[k](size);\n    });\n    return res;\n  });\n\n  return utils.curried2(result, arguments);\n}\n\n/**\n  - `shrink.record(shrs: { key: shrink a... }): shrink { key: a... }`\n*/\nfunction shrinkRecord(shrinksRecord) {\n  var keys = Object.keys(shrinksRecord);\n  var shrinks = keys.map(function (k) { return shrinksRecord[k]; });\n\n  var result = shrink.bless(function (rec) {\n    var values = keys.map(function (k) { return rec[k]; });\n    var shrinked = shrink.tuple(shrinks, values);\n\n    return shrinked.map(function (s) {\n      var res = {};\n      keys.forEach(function (k, i) {\n        res[k] = s[i];\n      });\n      return res;\n    });\n  });\n\n  return utils.curried2(result, arguments);\n}\n\nfunction arbitraryRecord(spec) {\n  var generatorSpec = {};\n  var shrinkSpec = {};\n  var showSpec = {};\n\n  Object.keys(spec).forEach(function (k) {\n    var arb = utils.force(spec[k]);\n    generatorSpec[k] = arb.generator;\n    shrinkSpec[k] = arb.shrink;\n    showSpec[k] = arb.show;\n  });\n\n  return arbitraryBless({\n    generator: generatorRecord(generatorSpec),\n    shrink: shrinkRecord(shrinkSpec),\n    show: function (m) {\n      return \"{\" + Object.keys(m).map(function (k) {\n        return k + \": \" + showSpec[k](m[k]);\n      }).join(\", \") + \"}\";\n    },\n  });\n}\n\nmodule.exports = {\n  generator: generatorRecord,\n  arbitrary: arbitraryRecord,\n  shrink: shrinkRecord,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/recordWithEnv.js":"\"use strict\";\n\nvar environment = require(\"./environment.js\");\nvar record = require(\"./record.js\");\nvar typify = require(\"./typify.js\");\nvar utils = require(\"./utils.js\");\n\n/**\n  ### Arbitrary records\n\n  - `record(spec: { key: arbitrary a... }, userenv: env?): arbitrary { key: a... }`\n\n      Generates a javascript object with given record spec.\n*/\nfunction recordWithEnv(spec, userenv) {\n  var env = userenv ? utils.merge(environment, userenv) : environment;\n\n  var parsedSpec = {};\n  Object.keys(spec).forEach(function (k) {\n    var arb = spec[k];\n    parsedSpec[k] = typeof arb === \"string\" ? typify.parseTypify(env, arb) : arb;\n  });\n\n  return record.arbitrary(parsedSpec);\n}\n\nmodule.exports = recordWithEnv;\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/environment.js":"/* @flow weak */\n\"use strict\";\n\nvar arbitrary = require(\"./arbitrary.js\");\nvar fn = require(\"./fn.js\");\nvar primitive = require(\"./primitive.js\");\nvar small = require(\"./small.js\");\nvar string = require(\"./string.js\");\nvar utils = require(\"./utils.js\");\n\nvar environment = utils.merge(primitive, string, {\n  pair: arbitrary.pair,\n  unit: arbitrary.unit,\n  either: arbitrary.either,\n  dict: arbitrary.dict,\n  array: arbitrary.array,\n  nearray: arbitrary.nearray,\n  json: arbitrary.json,\n  fn: fn.fn,\n  fun: fn.fn,\n  nonshrink: arbitrary.nonshrink,\n  small: small.arbitrary,\n});\n\nmodule.exports = environment;\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/fn.js":"/* @flow weak */\n\"use strict\";\n\nvar arbitraryBless = require(\"./arbitraryBless.js\");\nvar generator = require(\"./generator.js\");\nvar FMap = require(\"./finitemap.js\");\nvar json = require(\"./json.js\");\nvar shrink = require(\"./shrink.js\");\nvar utils = require(\"./utils.js\");\n\n/**\n  ### Arbitrary functions\n\n  - `fn(arb: arbitrary a): arbitrary (b -> a)`\n  - `fun(arb: arbitrary a): arbitrary (b -> a)`\n*/\n\nfunction fn(arb) {\n  arb = utils.force(arb || json.json);\n\n  return arbitraryBless({\n    generator: generator.bless(function (size) {\n      var m = new FMap();\n\n      var f = function (arg) {\n        if (!m.contains(arg)) {\n          var value = arb.generator(size);\n          m.insert(arg, value);\n        }\n\n        return m.get(arg);\n      };\n\n      f.internalMap = m;\n      return f;\n    }),\n\n    shrink: shrink.noop,\n    show: function (f) {\n      return \"[\" + f.internalMap.data.map(function (item) {\n        return \"\" + item[0] + \": \" + arb.show(item[1]);\n      }).join(\", \") + \"]\";\n    },\n  });\n}\n\nmodule.exports = {\n  fn: fn,\n  fun: fn,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/finitemap.js":"/* @flow weak */\n\"use strict\";\n\nvar utils = require(\"./utils.js\");\n\n/*\n  #### FMap (eq : a -> a -> bool) : FMap a\n\n  Finite map, with any object a key.\n\n  Short summary of member functions:\n\n  - FMap.insert (key : a) (value : any) : void\n  - FMap.get (key : a) : any\n  - FMap.contains (key : a) : obool\n*/\nfunction FMap(eq) {\n  this.eq = eq || utils.isEqual;\n  this.data = [];\n}\n\nFMap.prototype.contains = function FMapContains(key) {\n  for (var i = 0; i < this.data.length; i++) {\n    if (this.eq(this.data[i][0], key)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nFMap.prototype.insert = function FMapInsert(key, value) {\n  for (var i = 0; i < this.data.length; i++) {\n    if (this.eq(this.data[i][0], key)) {\n      this.data[i] = [key, value];\n      return;\n    }\n  }\n\n  this.data.push([key, value]);\n};\n\nFMap.prototype.get = function FMapGet(key) { // eslint-disable-line consistent-return\n  for (var i = 0; i < this.data.length; i++) {\n    if (this.eq(this.data[i][0], key)) {\n      return this.data[i][1];\n    }\n  }\n};\n\nmodule.exports = FMap;\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/small.js":"\"use strict\";\n\nvar generator = require(\"./generator.js\");\nvar arbitraryBless = require(\"./arbitraryBless.js\");\nvar arbitraryAssert = require(\"./arbitraryAssert.js\");\nvar utils = require(\"./utils.js\");\n\n/**\n  ### Small arbitraries\n\n  - `generator.small(gen: generator a): generator a`\n  - `small(arb: arbitrary a): arbitrary a`\n\n  Create a generator (abitrary) which will generate smaller values, i.e. generator's `size` parameter is decreased logarithmically.\n\n  ```js\n  jsc.property(\"small array of small natural numbers\", \"small (array nat)\", function (arr) {\n    return Array.isArray(arr);\n  });\n\n  jsc.property(\"small array of normal natural numbers\", \"(small array) nat\", function (arr) {\n    return Array.isArray(arr);\n  });\n  ```\n*/\n\nfunction smallGenerator(gen) {\n  // TODO: assertGenerator(gen)\n  return generator.bless(function (size) {\n    return gen(utils.ilog2(size));\n  });\n}\n\nfunction smallArbitraryImpl(arb) {\n  arbitraryAssert(arb);\n  return arbitraryBless({\n    generator: smallGenerator(arb.generator),\n    shrink: arb.shrink,\n    show: arb.show,\n  });\n}\n\nfunction smallArbitrary(arb) {\n  if (typeof arb === \"function\") {\n    return function () {\n      var resArb = arb.apply(arb, arguments);\n      return smallArbitraryImpl(resArb);\n    };\n  } else { /* if (typeof arb === \"object\") */\n    return smallArbitraryImpl(arb);\n  }\n}\n\nmodule.exports = {\n  generator: smallGenerator,\n  arbitrary: smallArbitrary,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/typify.js":"/* @flow weak */\n\"use strict\";\n\n/**\n  ### DSL for input parameters\n\n  There is a small DSL to help with `forall`. For example the two definitions below are equivalent:\n  ```js\n  var bool_fn_applied_thrice = jsc.forall(\"bool -> bool\", \"bool\", check);\n  var bool_fn_applied_thrice = jsc.forall(jsc.fn(jsc.bool), jsc.bool, check);\n  ```\n\n  The DSL is based on a subset of language recognized by [typify-parser](https://github.com/phadej/typify-parser):\n  - *identifiers* are fetched from the predefined environment.\n  - *applications* are applied as one could expect: `\"array bool\"` is evaluated to `jsc.array(jsc.bool)`.\n  - *functions* are supported: `\"bool -> bool\"` is evaluated to `jsc.fn(jsc.bool)`.\n  - *square brackets* are treated as a shorthand for the array type: `\"[nat]\"` is evaluated to `jsc.array(jsc.nat)`.\n  - *union*: `\"bool | nat\"` is evaluated to `jsc.sum([jsc.bool, jsc.nat])`.\n      - **Note** `oneof` cannot be shrinked, because the union is untagged, we don't know which shrink to use.\n  - *conjunction*: `\"bool & nat\"` is evaluated to `jsc.tuple(jsc.bool, jsc.nat)`.\n  - *anonymous records*: `\"{ b: bool; n: nat }\"` is evaluated to `jsc.record({ b: jsc.bool, n: jsc.nat })`.\n  - *EXPERIMENTAL: recursive types*: `\"rec list -> unit | (nat & list)\"`.\n*/\n\nvar arbitrary = require(\"./arbitrary.js\");\nvar assert = require(\"assert\");\nvar record = require(\"./record.js\");\nvar array = require(\"./array.js\");\nvar fn = require(\"./fn.js\");\nvar typifyParser = require(\"typify-parser\");\nvar utils = require(\"./utils.js\");\n\n// Forward declarations\nvar compileType;\nvar compileTypeArray;\n\nfunction compileIdent(env, type) {\n  var g = env[type.value];\n  if (!g) {\n    throw new Error(\"Unknown arbitrary: \" + type.value);\n  }\n  return g;\n}\n\nfunction compileApplication(env, type) {\n  var callee = compileType(env, type.callee);\n  var args = compileTypeArray(env, type.args);\n\n  return callee.apply(undefined, args);\n}\n\nfunction compileFunction(env, type) {\n  // we don't care about argument type\n  var result = compileType(env, type.result);\n  return fn.fn(result);\n}\n\nfunction compileBrackets(env, type) {\n  var arg = compileType(env, type.arg);\n  return array.array(arg);\n}\n\nfunction compileDisjunction(env, type) {\n  var args = compileTypeArray(env, type.args);\n  return arbitrary.sum(args);\n}\n\nfunction compileConjunction(env, type) {\n  var args = compileTypeArray(env, type.args);\n  return arbitrary.tuple(args);\n}\n\nfunction compileRecord(env, type) {\n  // TODO: use mapValues\n  var spec = {};\n  Object.keys(type.fields).forEach(function (key) {\n    spec[key] = compileType(env, type.fields[key]);\n  });\n  return record.arbitrary(spec);\n}\n\nfunction compileRecursive(env, type) {\n  assert(type.arg.type === \"disjunction\", \"recursive type's argument should be disjunction\");\n\n  // bound variable\n  var name = type.name;\n\n  var par = utils.partition(type.arg.args, function (t) {\n    return typifyParser.freeVars(t).indexOf(name) === -1;\n  });\n\n  var terminal = par[0];\n\n  if (terminal.length === 0) {\n    throw new Error(\"Recursive type without non-recursive branch\");\n  }\n\n  var terminalArb = compileType(env, {\n    type: \"disjunction\",\n    args: terminal,\n  });\n\n  return arbitrary.recursive(terminalArb, function (arb) {\n    var arbEnv = {};\n    arbEnv[name] = arb;\n    var newEnv = utils.merge(env, arbEnv);\n    return compileType(newEnv, type.arg);\n  });\n}\n\ncompileType = function compileTypeFn(env, type) {\n  switch (type.type) {\n    case \"ident\": return compileIdent(env, type);\n    case \"application\": return compileApplication(env, type);\n    case \"function\": return compileFunction(env, type);\n    case \"brackets\": return compileBrackets(env, type);\n    case \"disjunction\": return compileDisjunction(env, type);\n    case \"conjunction\": return compileConjunction(env, type);\n    case \"record\": return compileRecord(env, type);\n    case \"number\": return type.value;\n    case \"recursive\": return compileRecursive(env, type);\n    default: throw new Error(\"Unsupported typify ast type: \" + type.type);\n  }\n};\n\ncompileTypeArray = function compileTypeArrayFn(env, types) {\n  return types.map(function (type) {\n    return compileType(env, type);\n  });\n};\n\nfunction parseTypify(env, str) {\n  var type = typifyParser(str);\n  return compileType(env, type);\n}\n\nmodule.exports = {\n  parseTypify: parseTypify,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/functor.js":"/* @flow weak */\n\"use strict\";\n\nvar trampa = require(\"trampa\");\n\n/**\n  #### isPromise p : bool\n\n  Optimistic duck-type check for promises.\n  Returns `true` if p is an object with `.then` function property.\n*/\nfunction isPromise(p) {\n  /* eslint-disable no-new-object */\n  return new Object(p) === p && typeof p.then === \"function\";\n  /* eslint-enable non-new-object */\n}\n\n/**\n  #### map (Functor f) => (p : f a) (g : a -> b) : f b\n\n  This is functor map, known as `map` or `fmap`.\n  Essentially `f(p)`. If `p` is promise, returns new promise.\n  Using `map` makes code look very much [CPS-style](http://en.wikipedia.org/wiki/Continuation-passing_style).\n*/\nfunction map(p, g) {\n  if (isPromise(p)) {\n    return p.then(function (x) {\n      return map(x, g);\n    });\n  } else if (trampa.isTrampoline(p)) {\n    return p.jump(function (x) {\n      return map(x, g);\n    });\n  } else {\n    return g(p);\n  }\n}\n\n/**\n  #### bind (Functor f) => (k : a -> f b) (xs : a) (h : b -> f c) -> f c\n\n  This is almost monadic bind.\n*/\nfunction bind(f, xs, h) {\n  var r;\n  var exc;\n  try {\n    r = f.apply(undefined, xs);\n  } catch (e) {\n    r = false;\n    exc = e;\n  }\n\n  if (isPromise(r)) {\n    return r.then(\n      h,\n      function (e) {\n        // exc is always unset here\n        return h(false, e);\n      }\n    );\n  } else {\n    return h(r, exc);\n  }\n}\n\n// recursively unwrap trampoline and promises\nfunction run(x) {\n  if (isPromise(x)) {\n    return x.then(run);\n  } else if (trampa.isTrampoline(x)) {\n    return run(x.run());\n  } else {\n    return x;\n  }\n}\n\nfunction pure(x) {\n  if (isPromise(x)) {\n    return x;\n  } else {\n    return trampa.wrap(x);\n  }\n}\n\nmodule.exports = {\n  isPromise: isPromise,\n  map: map,\n  pure: pure,\n  bind: bind,\n  run: run,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/lib/suchthat.js":"/* @flow weak */\n\"use strict\";\n\nvar environment = require(\"./environment.js\");\nvar typify = require(\"./typify.js\");\nvar utils = require(\"./utils.js\");\nvar generator = require(\"./generator.js\");\nvar shrink = require(\"./shrink.js\");\nvar arbitraryBless = require(\"./arbitraryBless.js\");\n\n/**\n  - `suchthat(arb: arbitrary a, userenv: env?, p : a -> bool): arbitrary a`\n      Arbitrary of values that satisfy `p` predicate. It's advised that `p`'s accept rate is high.\n*/\nfunction suchthat(arb, userenv, predicate) {\n  var env;\n  if (arguments.length === 2) {\n    predicate = userenv;\n    env = environment;\n  } else {\n    env = utils.merge(environment, userenv);\n  }\n\n  arb = typeof arb === \"string\" ? typify.parseTypify(env, arb) : arb;\n  arb = utils.force(arb);\n\n  return arbitraryBless({\n    generator: generator.bless(function (size) {\n      for (var i = 0; ; i++) {\n        // if 5 tries failed, increase size\n        if (i > 5) {\n          i = 0;\n          size += 1;\n        }\n\n        var x = arb.generator(size);\n        if (predicate(x)) {\n          return x;\n        }\n      }\n    }),\n\n    shrink: shrink.bless(function (x) {\n      return arb.shrink(x).filter(predicate);\n    }),\n\n    show: arb.show,\n  });\n}\n\nmodule.exports = {\n  suchthat: suchthat,\n};\n","/home/travis/build/npmtest/node-npmtest-jsverify/node_modules/jsverify/karma.jasmine.conf.js":"/* eslint strict:[2,\"function\"] */\nmodule.exports = function (config) {\n  \"use strict\";\n  config.set({\n    basePath: \"\",\n    frameworks: [\"jasmine\"],\n    files: [\n      \"helpers/jasmineHelpers2.js\",\n      \"dist/jsverify.standalone.js\",\n      \"spec/*.js\",\n    ],\n    exclude: [\n    ],\n    preprocessors: {\n    },\n    reporters: [\"progress\"],\n    port: 9876,\n    colors: true,\n    logLevel: config.LOG_INFO,\n    autoWatch: false,\n    browsers: [\"Chrome\", \"Firefox\"],\n    singleRun: true,\n  });\n};\n"}